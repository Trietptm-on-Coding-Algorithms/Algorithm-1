#!/usr/bin/python
#-*- coding:utf-8 -*-
#寻找最大列算法
#问题概述，电影院大部分人不满意自己的座位，希望想出某种交换座位的方式
#M引索表示人，value表示该人想去的座位
#假设人和想去的位置一对一映射，则每个人都可以到自己想去的座位，没有人和自己争抢，这是最好的情况
#但好位置总是被很多人看上，这时就会出现一个位置被多个人期待，而这样便造成了有的位子没有被任何人期待
#但这样不好的位子总要有人坐，所以原主人只好自认倒霉，这样就可以在列表中删除该人，寻找剩下的最大排列
#持续上面的步骤，淘汰没有人期待的位置，直至成一对一映射

#朴素实现算法
def naive_max_perm(M,A=None):
    if A is None:
        A=set(range(len(M)))
        #A代表还没有被淘汰的人
    if len(A)==1:return A
    #如果A只剩下一个人，也没有必要再寻找
    B=set(M[i] for i in A)
    #B为没被淘汰的人所期待的座位
    C=A-B
    #为了找出没有人期待的位置，只需要集合A-集合B，求出存在A中而不存在B中的元素，即没有被任何人期待的位置
    if  C:
    #如果能找出这样的位子，就从A中淘汰，否则说明目前已为一对一映射，返回未被淘汰的人员列表
        A.remove(C.pop())
        return naive_max_perm(M,A)
        #讲该层未被淘汰的人员传入函数，递归调用
    return A
    #如果在该层找不到可以淘汰的位置，则返回A列表

#朴素算法为平方级，最浪费的操作无疑是对集合B的重复创建
#一种替代方案是为每个元素设置一个计数器，代表期望坐在这的人数
#当该计数值为0，则淘汰该人，同时该人期待坐的座位的计数值减1，因为这人已经被淘汰出局


#计数器算法
def max_perm(M):
    n=len(M)
    #总人数
    A=set(range(n))
    #未被淘汰的人员列表
    count=[0]*n
    #创建计数器
    for i in M:
        count[i]+=1
        #开始初始化计数器，统计每个位置被期待次数
    Q=[i for i in A if count==0]
    #开始淘汰不被期待的位置
    while  Q:
        i=Q.pop()
        A.remove(i)
        #淘汰出局
        j=M(j)
        #被淘汰人员所期待的位置
        count[j]-=1
        if count[j]==0:
            #如果该被减数变为0，加入Q，继续循环
            Q.append(j)


M=[2,2,0,5,3,5,7,4]
print naive_max_perm(M)
