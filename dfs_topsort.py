#!/usr/bin/python
#-*- coding:utf-8 -*-
#基于深度优先搜索的拓扑排序
#之前采用的算法是，找出没有入边的节点，逐步淘汰，直到没有节点
#这次采用的算法思想是，深度优先会沿着依赖关系，一直深入，至终点也就是没有出边的节点开始回溯
#在回溯过程正进行排序，没有出边的先加入列表，回溯上一级，上级进行循环递归另一分支，重复回溯操作
#直至循环完成，再返回上一级，如此一来，被依赖的节点总是比依赖的节点后加入，因为回溯需要先经过依赖关系递归到下一层

def dfs_topsort(G):
    S,res=set(),[]
    def recurse(u):
        #传入一个节点
        if u in S:continue
        S.add(u)
        #添加进访问过的列表
        for v in G[u]:
            recurse(v)
            #循环迭代依赖该节点的节点，进行递归
            #循环依然进行一次，然后递归深入，回溯回来后，才进行循环，可认为处理外一个分支后，再处理另外分支
        res.append(u)
    for u in G:
        #迭代所有节点
        recurse(u)
    res.reverse()
    #翻转列表
    return res
#无需担心是否会遗漏某一节点，因为会迭代所有节点，对选取的节点进行递归排序，而且将所有节点记录在S中
#下一次如果迭代更前面的节点，则会将中间遗漏的节点遍历一遍，遇到遍历过的节点则跳过，直接返回上一级
#最好的情况是第一次就选取了无入边的节点，那么只需要一次递归操作就可以完成
